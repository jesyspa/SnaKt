/cond_effects.kt:(121,146): info: Generated Viper text for compoundConditionalEffect:
method f$compoundConditionalEffect$TF$T$Boolean(b: Ref)
  returns (ret$0: Ref)
  ensures df$isSubtype(df$typeOf(ret$0), df$unitType())
  ensures true ==> df$boolFromRef(b) && false
{
  inhale df$isSubtype(df$typeOf(b), df$boolType())
  label lbl$0
  inhale df$isSubtype(df$typeOf(ret$0), df$unitType())
}

/cond_effects.kt:(190,220): warning: Cannot verify that if the function returns then (b && false).

/cond_effects.kt:(271,287): info: Generated Viper text for mayReturnNonNull:
method f$mayReturnNonNull$TF$NT$Any(x: Ref) returns (ret$0: Ref)
  ensures df$isSubtype(df$typeOf(ret$0), df$nullable(df$anyType()))
  ensures ret$0 == df$nullValue() ==>
    df$isSubtype(df$typeOf(x), df$intType())
{
  inhale df$isSubtype(df$typeOf(x), df$nullable(df$anyType()))
  ret$0 := x
  goto lbl$0
  label lbl$0
}

/cond_effects.kt:(328,360): warning: Cannot verify that if a null value is returned then x is Int.

/cond_effects.kt:(424,437): info: Generated Viper text for mayReturnNull:
method f$mayReturnNull$TF$NT$Any(x: Ref) returns (ret$0: Ref)
  ensures df$isSubtype(df$typeOf(ret$0), df$nullable(df$anyType()))
  ensures ret$0 != df$nullValue() ==>
    df$isSubtype(df$typeOf(x), df$intType())
{
  inhale df$isSubtype(df$typeOf(x), df$nullable(df$anyType()))
  ret$0 := x
  goto lbl$0
  label lbl$0
}

/cond_effects.kt:(478,513): warning: Cannot verify that if a non-null value is returned then x is Int.

/cond_effects.kt:(723,741): info: Generated Viper text for isNullOrEmptyWrong:
method f$isNullOrEmptyWrong$TF$NT$CharSequence(seq: Ref)
  returns (ret$0: Ref)
  ensures df$isSubtype(df$typeOf(ret$0), df$boolType())
  ensures df$boolFromRef(ret$0) == false ==> seq != df$nullValue()
{
  inhale df$isSubtype(df$typeOf(seq), df$nullable(df$c$pkg$kotlin$CharSequence()))
  inhale seq != df$nullValue() ==>
    acc(p$pkg$kotlin$c$CharSequence$shared(seq), wildcard)
  if (!(seq == df$nullValue())) {
    var anon$0: Ref
    var anon$1: Ref
    anon$1 := pg$length(seq)
    anon$0 := anon$1
    inhale df$isSubtype(df$typeOf(anon$0), df$intType())
    ret$0 := sp$notBool(df$boolToRef(df$intFromRef(anon$0) == 0))
  } else {
    ret$0 := df$boolToRef(false)}
  goto lbl$0
  label lbl$0
}

method pg$length(this$dispatch: Ref) returns (ret: Ref)


/cond_effects.kt:(796,832): warning: Cannot verify that if a false value is returned then seq != null.

/cond_effects.kt:(925,942): info: Generated Viper text for recursiveContract:
method f$recursiveContract$TF$T$Int$NT$Any(n: Ref, x: Ref)
  returns (ret$0: Ref)
  ensures df$isSubtype(df$typeOf(ret$0), df$boolType())
  ensures df$boolFromRef(ret$0) == true ==>
    df$isSubtype(df$typeOf(x), df$stringType())
{
  inhale df$isSubtype(df$typeOf(n), df$intType())
  inhale df$isSubtype(df$typeOf(x), df$nullable(df$anyType()))
  if (df$intFromRef(n) == 0) {
    ret$0 := df$boolToRef(df$isSubtype(df$typeOf(x), df$intType()))
  } else {
    ret$0 := f$recursiveContract$TF$T$Int$NT$Any(sp$minusInts(n, df$intToRef(1)),
      x)}
  goto lbl$0
  label lbl$0
}

/cond_effects.kt:(994,1029): warning: Cannot verify that if a true value is returned then x is String.
